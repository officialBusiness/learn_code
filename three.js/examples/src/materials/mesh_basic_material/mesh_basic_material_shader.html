<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=0">
		<link rel="icon" href="../../../icon.png">
		<title>mesh_basic_material.shader</title>
		<link href="../../../default_css.css" rel="stylesheet" type="text/css"/>
	</head>
	<!--

	-->
	<body>
		<canvas id="renderCanvas"></canvas>
		<script type="importmap">
			{
				"imports": {
						"three": "../../../../source/src/THREE.js"
				}
			}
		</script>
		<script type="module">
			import '../../../module.js';
			import * as THREE from 'three';
			import { OrbitControls } from '../../../jsm/jsm.js';

			const canvas = document.getElementById('renderCanvas');

			const scene = new THREE.Scene();

			const renderer = new THREE.WebGLRenderer({
				canvas,
				antialias: true
			});

			renderer.setSize( canvas.clientWidth, canvas.clientHeight );

			renderer.domElement.id = 'renderCanvas';

			document.body.appendChild( renderer.domElement );


			const camera = new THREE.PerspectiveCamera( 75, canvas.clientWidth / canvas.clientHeight, 0.1, 200 );

			camera.position.z = 2;

			scene.add(camera);

			const controls = new OrbitControls( camera, renderer.domElement );

			const plane = new THREE.BufferGeometry();
			plane.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( [
				-1.0, -1.0,  0.0,
				 1.0, -1.0,  0.0,
				-1.0,  1.0,  0.0,
				 1.0,  1.0,  0.0,
			] ), 3 ) );

			plane.setAttribute('uv', new THREE.BufferAttribute( new Float32Array( [
				0.0, 0.0,
				1.0, 0.0,
				0.0, 1.0,
				1.0, 1.0,
			] ), 2) );

			plane.setIndex( [
				1, 3, 2,
				2, 0, 1
			] );

			const shaderMaterial = new THREE.ShaderMaterial({
				// fog: true,

				uniforms: {
					// common
					diffuse: {
						value: new THREE.Color( 0xffffff )
					},
					opacity: {
						value: 1.0
					},
					map: {
						value: new THREE.TextureLoader().load('../../../assets/images/logo1.jpg'),
					},
					mapTransform: {
						value: new THREE.Matrix3()
					},

					alphaMap: {
						value: null
					},
					alphaMapTransform: {
						value: new THREE.Matrix3()
					},
					alphaTest: {
						value: 0
					},

					// specularmap
					specularMap: {
						value: null
					},
					specularMapTransform: {
						value: new THREE.Matrix3()
					},

					// envmap
					envMap: {
						value: null
					},
					envMapRotation: {
						value: new THREE.Matrix3()
					},
					flipEnvMap: {
						value: - 1
					},
					reflectivity: {
						value: 1.0
					},
					ior: {
						value: 1.5
					},
					refractionRatio: {
						value: 0.98
					},

					// aomap
					aoMap: {
						value: null
					},
					aoMapIntensity: {
						value: 1
					},
					aoMapTransform: {
						value: new THREE.Matrix3()
					},

					// lightmap
					lightMap: {
						value: null
					},
					lightMapIntensity: {
						value: 1
					},
					lightMapTransform: {
						value: new THREE.Matrix3()
					},

					// fog
					fog: {
						fogDensity: {
							value: 0.00025
						},
						fogNear: {
							value: 1
						},
						fogFar: {
							value: 2000
						},
						fogColor: {
							value:  new THREE.Color( 0xffffff )
						}
					},
				},
				vertexShader: `
					#include <common>
					#include <batching_pars_vertex>
					#include <uv_pars_vertex>
					#include <envmap_pars_vertex>
					#include <color_pars_vertex>
					#include <fog_pars_vertex>
					#include <morphtarget_pars_vertex>
					#include <skinning_pars_vertex>
					#include <logdepthbuf_pars_vertex>
					#include <clipping_planes_pars_vertex>

					void main() {

						#include <uv_vertex>
						#include <color_vertex>
						#include <morphinstance_vertex>
						#include <morphcolor_vertex>
						#include <batching_vertex>

						#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )

							#include <beginnormal_vertex>
							#include <morphnormal_vertex>
							#include <skinbase_vertex>
							#include <skinnormal_vertex>
							#include <defaultnormal_vertex>

						#endif

						#include <begin_vertex>
						#include <morphtarget_vertex>
						#include <skinning_vertex>
						#include <project_vertex>
						#include <logdepthbuf_vertex>
						#include <clipping_planes_vertex>

						#include <worldpos_vertex>
						#include <envmap_vertex>
						#include <fog_vertex>
					}
				`,
				fragmentShader: `
					uniform vec3 diffuse;
					uniform float opacity;

					#ifndef FLAT_SHADED

						varying vec3 vNormal;

					#endif

					#include <common>
					#include <dithering_pars_fragment>
					#include <color_pars_fragment>
					#include <uv_pars_fragment>
					#include <map_pars_fragment>
					#include <alphamap_pars_fragment>
					#include <alphatest_pars_fragment>
					#include <alphahash_pars_fragment>
					#include <aomap_pars_fragment>
					#include <lightmap_pars_fragment>
					#include <envmap_common_pars_fragment>
					#include <envmap_pars_fragment>
					#include <fog_pars_fragment>
					#include <specularmap_pars_fragment>
					#include <logdepthbuf_pars_fragment>
					#include <clipping_planes_pars_fragment>

					void main() {

						vec4 diffuseColor = vec4( diffuse, opacity );
						#include <clipping_planes_fragment>

						#include <logdepthbuf_fragment>
						#include <map_fragment>
						#include <color_fragment>
						#include <alphamap_fragment>
						#include <alphatest_fragment>
						#include <alphahash_fragment>
						#include <specularmap_fragment>

						ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

						// accumulation (baked indirect lighting only)
						#ifdef USE_LIGHTMAP

							vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
							reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;

						#else

							reflectedLight.indirectDiffuse += vec3( 1.0 );

						#endif

						// modulation
						#include <aomap_fragment>

						reflectedLight.indirectDiffuse *= diffuseColor.rgb;

						vec3 outgoingLight = reflectedLight.indirectDiffuse;

						#include <envmap_fragment>

						#include <opaque_fragment>
						#include <tonemapping_fragment>
						#include <colorspace_fragment>
						#include <fog_fragment>
						#include <premultiplied_alpha_fragment>
						#include <dithering_fragment>
					}
				`,
			})

			// deal parameters
			shaderMaterial.map = shaderMaterial.uniforms.map.value;

			const mesh = new THREE.Mesh( plane, shaderMaterial );

			scene.add(mesh);

			const stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );


			// 待完善
			initGui();
			function initGui(){

				const gui = new lil.GUI();

				// gui.add( shaderMaterial.uniforms.intensity, 'value', 0, 1, 0.01 );
			}


			// function addTextureUv(){

			// }

			loop();
			function loop() {

				renderer.render( scene, camera );

				stats.update();

				requestAnimationFrame(loop)
			}
		</script>
	</body>
</html>
