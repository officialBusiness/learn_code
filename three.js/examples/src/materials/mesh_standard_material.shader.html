<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=0">
		<link rel="icon" href="../../icon.png">
		<title>mesh_standard_material.shader</title>
		<link href="../../default_css.css" rel="stylesheet" type="text/css"/>
	</head>
	<!--

	-->
	<body>
		<canvas id="renderCanvas"></canvas>
		<script type="importmap">
			{
				"imports": {
						"three": "../../../source/src/THREE.js"
				}
			}
		</script>
		<script type="module">
			import '../../module.js';
			import * as THREE from 'three';
			import { OrbitControls } from '../../jsm/jsm.js';

			const canvas = document.getElementById('renderCanvas');

			const scene = new THREE.Scene();

			const renderer = new THREE.WebGLRenderer({
				canvas,
				antialias: true
			});

			renderer.setSize( canvas.clientWidth, canvas.clientHeight );

			renderer.domElement.id = 'renderCanvas';

			document.body.appendChild( renderer.domElement );


			const camera = new THREE.PerspectiveCamera( 75, canvas.clientWidth / canvas.clientHeight, 0.1, 200 );

			camera.position.z = 2;

			scene.add(camera);

      const controls = new OrbitControls( camera, renderer.domElement );

      const plane = new THREE.BufferGeometry();
      plane.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( [
        -1.0, -1.0,  0.0,
         1.0, -1.0,  0.0,
        -1.0,  1.0,  0.0,
         1.0,  1.0,  0.0,
      ] ), 3 ) );

      plane.setAttribute('uv', new THREE.BufferAttribute( new Float32Array( [
        0.0, 0.0,
        1.0, 0.0,
        0.0, 1.0,
        1.0, 1.0,
      ] ), 2) );

      plane.setIndex( [
        1, 3, 2,
        2, 0, 1
      ] );

			const shaderMaterial = new THREE.ShaderMaterial({
				// fog: true,

				uniforms: {
					// common

					diffuse: {
						value: new THREE.Color( 0xffffff )
					},
					opacity: {
						value: 1.0
					},

					map: {
						value: null
					},
					mapTransform: {
						value: new THREE.Matrix3()
					},

					alphaMap: {
						value: null
					},
					alphaMapTransform: {
						value: new THREE.Matrix3()
					},

					alphaTest: {
						value: 0
					},

					// envmap

					envMap: {
						value: null
					},
					envMapRotation: {
						value: new THREE.Matrix3()
					},
					flipEnvMap: {
						value: -1
					},
					reflectivity: {
						value: 1.0
					}, // basic, lambert, phong
					ior: {
						value: 1.5
					}, // physical
					refractionRatio: {
						value: 0.98
					}, // basic, lambert, phong

					// aomap

					aoMap: {
						value: null
					},
					aoMapIntensity: {
						value: 1
					},
					aoMapTransform: {
						value: /*@__PURE__*/ new THREE.Matrix3()
					},

					// lightmap

					lightMap: {
						value: null
					},
					lightMapIntensity: {
						value: 1
					},
					lightMapTransform: {
						value: /*@__PURE__*/ new THREE.Matrix3()
					},

					// emissivemap

					emissiveMap: {
						value: null
					},
					emissiveMapTransform: {
						value: /*@__PURE__*/ new THREE.Matrix3()
					},

					// bumpmap

					bumpMap: {
						value: null
					},
					bumpMapTransform: {
						value: /*@__PURE__*/ new THREE.Matrix3()
					},
					bumpScale: {
						value: 1
					},

					// normalmap

					normalMap: {
						value: null
					},
					normalMapTransform: {
						value: /*@__PURE__*/ new THREE.Matrix3()
					},
					normalScale: {
						value: new THREE.Vector2( 1, 1 )
					},

					// displacementmap

					displacementMap: {
						value: null
					},
					displacementMapTransform: {
						value: new THREE.Matrix3()
					},
					displacementScale: {
						value: 1
					},
					displacementBias: {
						value: 0
					},

					// roughnessmap

					roughnessMap: {
						value: null
					},
					roughnessMapTransform: {
						value: new THREE.Matrix3()
					},

					// metalnessmap

					metalnessMap: {
						value: null
					},
					metalnessMapTransform: {
						value: new THREE.Matrix3()
					},

					// fog

					fogDensity: {
						value: 0.00025
					},
					fogNear: {
						value: 1
					},
					fogFar: {
						value: 2000
					},
					fogColor: {
						value: new THREE.Color( 0xffffff )
					},

					// lights

					ambientLightColor: { value: [] },

					lightProbe: { value: [] },

					directionalLights: { value: [], properties: {
						direction: {},
						color: {}
					} },

					directionalLightShadows: { value: [], properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {}
					} },

					directionalShadowMap: { value: [] },
					directionalShadowMatrix: { value: [] },

					spotLights: { value: [], properties: {
						color: {},
						position: {},
						direction: {},
						distance: {},
						coneCos: {},
						penumbraCos: {},
						decay: {}
					} },

					spotLightShadows: { value: [], properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {}
					} },

					spotLightMap: { value: [] },
					spotShadowMap: { value: [] },
					spotLightMatrix: { value: [] },

					pointLights: { value: [], properties: {
						color: {},
						position: {},
						decay: {},
						distance: {}
					} },

					pointLightShadows: { value: [], properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {},
						shadowCameraNear: {},
						shadowCameraFar: {}
					} },

					pointShadowMap: { value: [] },
					pointShadowMatrix: { value: [] },

					hemisphereLights: { value: [], properties: {
						direction: {},
						skyColor: {},
						groundColor: {}
					} },

					// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
					rectAreaLights: { value: [], properties: {
						color: {},
						position: {},
						width: {},
						height: {}
					} },

					ltc_1: { value: null },
					ltc_2: { value: null },


					emissive: {
						value: new THREE.Color( 0xff0000 )
					},
					roughness: {
						value: 1.0
					},
					metalness: {
						value: 0.0
					},
					envMapIntensity: {
						value: 1
					},
				},
				vertexShader: `
					#define STANDARD

					varying vec3 vViewPosition;

					#ifdef USE_TRANSMISSION

						varying vec3 vWorldPosition;

					#endif

					#include <common>
					#include <batching_pars_vertex>
					#include <uv_pars_vertex>
					#include <displacementmap_pars_vertex>
					#include <color_pars_vertex>
					#include <fog_pars_vertex>
					#include <normal_pars_vertex>
					#include <morphtarget_pars_vertex>
					#include <skinning_pars_vertex>
					#include <shadowmap_pars_vertex>
					#include <logdepthbuf_pars_vertex>
					#include <clipping_planes_pars_vertex>

					void main() {

						#include <uv_vertex>
						#include <color_vertex>
						#include <morphinstance_vertex>
						#include <morphcolor_vertex>
						#include <batching_vertex>

						#include <beginnormal_vertex>
						#include <morphnormal_vertex>
						#include <skinbase_vertex>
						#include <skinnormal_vertex>
						#include <defaultnormal_vertex>
						#include <normal_vertex>

						#include <begin_vertex>
						#include <morphtarget_vertex>
						#include <skinning_vertex>
						#include <displacementmap_vertex>
						#include <project_vertex>
						#include <logdepthbuf_vertex>
						#include <clipping_planes_vertex>

						vViewPosition = - mvPosition.xyz;

						#include <worldpos_vertex>
						#include <shadowmap_vertex>
						#include <fog_vertex>

					#ifdef USE_TRANSMISSION

						vWorldPosition = worldPosition.xyz;

					#endif
					}
				`,
				fragmentShader: `
					#define STANDARD

					#ifdef PHYSICAL
						#define IOR
						#define USE_SPECULAR
					#endif

					uniform vec3 diffuse;
					uniform vec3 emissive;
					uniform float roughness;
					uniform float metalness;
					uniform float opacity;

					#ifdef IOR
						uniform float ior;
					#endif

					#ifdef USE_SPECULAR
						uniform float specularIntensity;
						uniform vec3 specularColor;

						#ifdef USE_SPECULAR_COLORMAP
							uniform sampler2D specularColorMap;
						#endif

						#ifdef USE_SPECULAR_INTENSITYMAP
							uniform sampler2D specularIntensityMap;
						#endif
					#endif

					#ifdef USE_CLEARCOAT
						uniform float clearcoat;
						uniform float clearcoatRoughness;
					#endif

					#ifdef USE_IRIDESCENCE
						uniform float iridescence;
						uniform float iridescenceIOR;
						uniform float iridescenceThicknessMinimum;
						uniform float iridescenceThicknessMaximum;
					#endif

					#ifdef USE_SHEEN
						uniform vec3 sheenColor;
						uniform float sheenRoughness;

						#ifdef USE_SHEEN_COLORMAP
							uniform sampler2D sheenColorMap;
						#endif

						#ifdef USE_SHEEN_ROUGHNESSMAP
							uniform sampler2D sheenRoughnessMap;
						#endif
					#endif

					#ifdef USE_ANISOTROPY
						uniform vec2 anisotropyVector;

						#ifdef USE_ANISOTROPYMAP
							uniform sampler2D anisotropyMap;
						#endif
					#endif

					varying vec3 vViewPosition;

					#include <common>
					#include <packing>
					#include <dithering_pars_fragment>
					#include <color_pars_fragment>
					#include <uv_pars_fragment>
					#include <map_pars_fragment>
					#include <alphamap_pars_fragment>
					#include <alphatest_pars_fragment>
					#include <alphahash_pars_fragment>
					#include <aomap_pars_fragment>
					#include <lightmap_pars_fragment>
					#include <emissivemap_pars_fragment>
					#include <iridescence_fragment>
					#include <cube_uv_reflection_fragment>
					#include <envmap_common_pars_fragment>
					#include <envmap_physical_pars_fragment>
					#include <fog_pars_fragment>
					#include <lights_pars_begin>
					#include <normal_pars_fragment>
					#include <lights_physical_pars_fragment>
					#include <transmission_pars_fragment>
					#include <shadowmap_pars_fragment>
					#include <bumpmap_pars_fragment>
					#include <normalmap_pars_fragment>
					#include <clearcoat_pars_fragment>
					#include <iridescence_pars_fragment>
					#include <roughnessmap_pars_fragment>
					#include <metalnessmap_pars_fragment>
					#include <logdepthbuf_pars_fragment>
					#include <clipping_planes_pars_fragment>

					void main() {

						vec4 diffuseColor = vec4( diffuse, opacity );
						#include <clipping_planes_fragment>

						ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
						vec3 totalEmissiveRadiance = emissive;

						#include <logdepthbuf_fragment>
						#include <map_fragment>
						#include <color_fragment>
						#include <alphamap_fragment>
						#include <alphatest_fragment>
						#include <alphahash_fragment>
						#include <roughnessmap_fragment>
						#include <metalnessmap_fragment>
						#include <normal_fragment_begin>
						#include <normal_fragment_maps>
						#include <clearcoat_normal_fragment_begin>
						#include <clearcoat_normal_fragment_maps>
						#include <emissivemap_fragment>

						// accumulation
						#include <lights_physical_fragment>
						#include <lights_fragment_begin>
						#include <lights_fragment_maps>
						#include <lights_fragment_end>

						// modulation
						#include <aomap_fragment>

						vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
						vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

						#include <transmission_fragment>

						vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

						#ifdef USE_SHEEN

							// Sheen energy compensation approximation calculation can be found at the end of
							// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
							float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );

							outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;

						#endif

						#ifdef USE_CLEARCOAT

							float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );

							vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

							outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;

						#endif

						#include <opaque_fragment>
						#include <tonemapping_fragment>
						#include <colorspace_fragment>
						#include <fog_fragment>
						#include <premultiplied_alpha_fragment>
						#include <dithering_fragment>

					}
				`,
			})

			// deal parameters
			// shaderMaterial.map = shaderMaterial.uniforms.map.value;

			const mesh = new THREE.Mesh( plane, shaderMaterial );

			scene.add(mesh);

			const stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );


			// 待完善
			initGui();
			function initGui(){

				const gui = new lil.GUI();

				// gui.add( shaderMaterial.uniforms.intensity, 'value', 0, 1, 0.01 );
			}


			// function addTextureUv(){

			// }

			loop();
			function loop() {

				renderer.render( scene, camera );

				stats.update();

				requestAnimationFrame(loop)
			}
		</script>
	</body>
</html>
